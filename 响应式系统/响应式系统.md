# 响应式系统

和 react 相比，vue 多了一个响应式系统，初略来看是为了更高效的更新 DOM，避免一些不必要的 dom diff。实现的原理就是依赖处理。

## 问题一
修改一个不显示在页面上的状态，会发生什么？

## 详细
什么是响应式系统？

核心其实就是观察者模式，首先 data 的每个属性都有一个闭包保存了 dep 实例，dep 是处理值之间的依赖关系。

什么情况下会存在状态之间相互依赖的情况呢？
- 组件的渲染依赖被渲染的状态
- computed 依赖 get 中用到的状态
- watch 处理函数的调用依赖观察的状态

下面一一进行分析

### 组件渲染

当改变某个状态的时候，视图也会发生变化。等于要讨论 vue 的最核心机制，假设有这样一个组件：

```javascript
new Vue({
    el: '#app',
    template: '<div>{{hp}} - {{mp}}</div>',
    data() {
        return {
            hp: 100,
            mp: 50,
        };
    },
});
```

最终得到的 vm 是怎么样的？

`watchers`保存了一个`Watcher`实例，实际上，`watchers`会保存实例化过程中的所有`watcher`。那问题又来了，什么情况下会创建`watcher`实例呢？

- mountComponent，此时的`watcher`是直接赋给了`vm._watcher`所以不在`watchers`中的。
- initComputed，由于这次代码没有`computed`所以也不讨论。
- initWatcher
- 状态是复杂类型


打个比方，A 和 B 两个人，他们都有一部手机。

这时，别人给了 A 一个东西，A 于是就这唯一的一部手机拨打，依次给每个号码打。

现在暂时只有一个号码，也打。另一边，被拨打的人一旦接到电话，就做一件之前约定好的事。

对应到实际情况，手机就是 dep，打电话就是 dep.notify，而电话号码就是 watcher，hp 被获取时，就会执行 updateComponent 实现重新渲染页面。

当时为什么 A 的手机里会有别人的号码呢？其实是这样的，最最最最开始的时候，有这么一条规则：

要从某个人那里获取东西前，先把自己的号码写在大屏幕上。

小明将自己的号码公布在大屏幕上，然后向 A 索要了东西，A 就是在这时记下的号码。
对应到实际情况，就是在 mountComponent 函数中，实例化 Watcher 并调用了 get 方法，而 get 方法最开始的 pustTarget(this) 就是公布号码。然后会渲染视图，渲染视图要用到 hp 就是向 A 索要了东西。hp 在 getter 内判断是否有 Dep.target，就是屏幕上是否有号码，有就 push 到 dep.subs 中，就是记下号码。



